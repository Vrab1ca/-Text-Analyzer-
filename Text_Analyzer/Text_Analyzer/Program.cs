using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Text_Analyzer
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Set the console encoding to UTF-8 to support Bulgarian characters
            Console.OutputEncoding = Encoding.UTF8;

            while (true) // Loop to keep the program running until the user exits
            {
                // Display the input prompt with the exit button in a box
                Console.WriteLine("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
                Console.WriteLine("–í—ä–≤–µ–¥–µ—Ç–µ —Ç–µ–∫—Å—Ç (–∏–ª–∏ 'Ext' –∑–∞ –∏–∑—Ö–æ–¥): ");
                Console.WriteLine("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");

                string inputText = Console.ReadLine();

                // Check if the user wants to exit
                if (inputText.Trim().Equals("Ext", StringComparison.OrdinalIgnoreCase))
                {
                    Console.WriteLine("–ò–∑–ª–∏–∑–∞–Ω–µ –æ—Ç –ø—Ä–æ–≥—Ä–∞–º–∞—Ç–∞...");
                    break; // Exit the loop and end the program
                }

                // Common Bulgarian stop words to ignore
                HashSet<string> stopWords = new HashSet<string> { "–∏", "–Ω–∞", "–≤", "—Å", "–∑–∞", "–¥–∞", "–æ—Ç", "—Å–µ", "–∫–∞—Ç–æ", "–ø–æ", "—á–µ", "–Ω–µ", "—Ç–æ–π", "–∫–æ–∏—Ç–æ", "—Å—ä—Å", "—Ç—è", "—Ç–µ", "–≥–æ", "–º—É", "–≥–∏", "—Å–∏", "—Ç–∞–∑–∏", "—Ç—É–∫", "—Ç–∞–º", "—Å—ä—â–æ", "—Å–∞", "—Å–º–µ", "—Å—Ç–µ", "—Å–∞–º–æ", "–æ—â–µ", "–º–æ–∂–µ", "–±–∏", "–µ" };

                // Analyze the text
                int wordCount = CountWords(inputText);
                int charCount = CountCharacters(inputText);
                var wordFrequency = GetWordFrequency(inputText, stopWords);
                var sentenceStats = AnalyzeSentences(inputText);
                var punctuationStats = AnalyzePunctuation(inputText);
                string tense = DetectTense(inputText);

                // Display results
                Console.WriteLine($"\n‚ñí–ë—Ä–æ–π –¥—É–º–∏‚ñí: {wordCount}");
                Console.WriteLine($"‚ñô–ë—Ä–æ–π —Å–∏–º–≤–æ–ª–∏‚ñú: {charCount}");
                Console.WriteLine($"‚ñ¨–ë—Ä–æ–π –∏–∑—Ä–µ—á–µ–Ω–∏—è‚ñ¨: {sentenceStats.SentenceCount}");
                Console.WriteLine($"‚åò–°—Ä–µ–¥–Ω–∞ –¥—ä–ª–∂–∏–Ω–∞ –Ω–∞ –∏–∑—Ä–µ—á–µ–Ω–∏—è—Ç–∞‚åò: {sentenceStats.AverageSentenceLength:F2} –¥—É–º–∏");

                Console.WriteLine("\n‚òµ–ß–µ—Å—Ç–æ —Å—Ä–µ—â–∞–Ω–∏ –¥—É–º–∏‚òµ:");
                var topWords = wordFrequency.OrderByDescending(p => p.Value).Take(10);
                foreach (var pair in topWords)
                {
                    Console.WriteLine($"{pair.Key}: {pair.Value} –ø—ä—Ç–∏");
                }

                Console.WriteLine("\n‚ñ£–£–ø–æ—Ç—Ä–µ–±–∞ –Ω–∞ –ø—Ä–µ–ø–∏–Ω–∞—Ç–µ–ª–Ω–∏ –∑–Ω–∞—Ü–∏‚ñ£:");
                Console.WriteLine($"‚åë–¢–æ—á–∫–∏ (.)‚åë: {punctuationStats['.']}");
                Console.WriteLine($"‚ñ™–ó–∞–ø–µ—Ç–∞–∏ (,)‚ñ™: {punctuationStats[',']}");
                Console.WriteLine($"‚ñ©–í—ä–ø—Ä–æ—Å–∏—Ç–µ–ª–Ω–∏ –∑–Ω–∞—Ü–∏ (?)‚ñ©: {punctuationStats['?']}");
                Console.WriteLine($"‚óé–£–¥–∏–≤–∏—Ç–µ–ª–Ω–∏ –∑–Ω–∞—Ü–∏ (!)‚óé: {punctuationStats['!']}");
                Console.WriteLine($"‚óã–ú–Ω–æ–≥–æ—Ç–æ—á–∏—è (‚Ä¶)‚óã: {punctuationStats['‚Ä¶']}");
                Console.WriteLine($"‚î£–¢–æ—á–∫–∞ –∏ –∑–∞–ø–µ—Ç–∞—è (;)‚î®: {punctuationStats[';']}");
                Console.WriteLine($"‚ïç–î–≤–æ–µ—Ç–æ—á–∏—è (:)‚ïç: {punctuationStats[':']}");
                Console.WriteLine($"‚ïû–¢–∏—Ä–µ (‚Äì)‚ï°: {punctuationStats['‚Äì']}");
                Console.WriteLine($"‚ïè–î–µ—Ñ–∏—Å (-)‚ïè: {punctuationStats['-']}");
                Console.WriteLine($"üîπ–ö–∞–≤–∏—á–∫–∏ (‚Äú‚Äù)üîπ: {punctuationStats['‚Äú']}");
                Console.WriteLine($"‚ñ¶–°–∫–æ–±–∏ (())‚ñ¶: {punctuationStats['(']}");

                Console.WriteLine($"\n‚ùí–í—Ä–µ–º–µ –Ω–∞ —Ç–µ–∫—Å—Ç–∞: {tense}");

                // Add a separator for better readability
                Console.WriteLine("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
            }
        }

        // Count the total number of words
        static int CountWords(string text)
        {
            // Split text into words using spaces and punctuation as separators
            string[] words = text.Split(new[] { ' ', '\t', '\n', '\r', '.', ',', '!', '?', ';', ':', '(', ')' }, StringSplitOptions.RemoveEmptyEntries);
            return words.Length;
        }

        // Count the total number of characters (excluding spaces and punctuation)
        static int CountCharacters(string text)
        {
            // Remove spaces and punctuation marks
            string cleanedText = new string(text.Where(c => !char.IsPunctuation(c) && !char.IsWhiteSpace(c)).ToArray());
            return cleanedText.Length;
        }

        // Get the frequency of each word, ignoring stop words
        static Dictionary<string, int> GetWordFrequency(string text, HashSet<string> stopWords)
        {
            string[] words = text.Split(new[] { ' ', '\t', '\n', '\r', '.', ',', '!', '?', ';', ':', '(', ')' }, StringSplitOptions.RemoveEmptyEntries);
            Dictionary<string, int> frequency = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

            foreach (string word in words)
            {
                string cleanedWord = word.Trim().ToLower();
                if (!stopWords.Contains(cleanedWord))
                {
                    if (frequency.ContainsKey(cleanedWord))
                    {
                        frequency[cleanedWord]++;
                    }
                    else
                    {
                        frequency[cleanedWord] = 1;
                    }
                }
            }

            return frequency;
        }

        // Analyze sentence length and count
        static (int SentenceCount, double AverageSentenceLength) AnalyzeSentences(string text)
        {
            // Split text into sentences using '.', '!', and '?' as separators
            string[] sentences = text.Split(new[] { '.', '!', '?' }, StringSplitOptions.RemoveEmptyEntries);
            int sentenceCount = sentences.Length;
            int totalWordsInSentences = 0;

            foreach (string sentence in sentences)
            {
                totalWordsInSentences += CountWords(sentence);
            }

            double averageSentenceLength = sentenceCount > 0 ? (double)totalWordsInSentences / sentenceCount : 0;
            return (sentenceCount, averageSentenceLength);
        }

        // Analyze punctuation usage
        static Dictionary<char, int> AnalyzePunctuation(string text)
        {
            // Initialize dictionary with all punctuation marks
            Dictionary<char, int> punctuationStats = new Dictionary<char, int>
            {
                { '.', 0 },
                { ',', 0 },
                { '?', 0 },
                { '!', 0 },
                { '‚Ä¶', 0 },
                { ';', 0 },
                { ':', 0 },
                { '‚Äì', 0 },
                { '-', 0 },
                { '‚Äú', 0 },
                { '‚Äù', 0 },
                { '(', 0 },
                { ')', 0 }
            };

            // Count each punctuation mark
            foreach (char c in text)
            {
                if (punctuationStats.ContainsKey(c))
                {
                    punctuationStats[c]++;
                }
            }

            // Handle ellipses (three consecutive dots)
            punctuationStats['‚Ä¶'] = text.Split(new[] { "‚Ä¶" }, StringSplitOptions.None).Length - 1;

            return punctuationStats;
        }

        // Detect the tense of the text
        static string DetectTense(string text)
        {
            // Common Bulgarian verb forms and tense indicators
            HashSet<string> presentTenseIndicators = new HashSet<string> { "—Å—ä–º", "–µ", "—Å–º–µ", "—Å—Ç–µ", "—Å–∞", "–º–æ–≥–∞", "–∏—Å–∫–∞–º", "–ø—Ä–∞–≤—è", "—Ö–æ–¥—è", "–ø–∏—à–∞", "—á–µ—Ç–∞" };
            HashSet<string> pastIndefiniteIndicators = new HashSet<string> { "–±—è—Ö", "–±–µ—à–µ", "–±—è—Ö–º–µ", "–±—è—Ö—Ç–µ", "–±—è—Ö–∞", "–º–æ–∂–µ—Ö", "–∏—Å–∫–∞—Ö", "–ø—Ä–∞–≤–∏—Ö", "—Ö–æ–¥–∏—Ö", "–ø–∏—Å–∞—Ö", "—á–µ—Ç–æ—Ö" };
            HashSet<string> pastImperfectIndicators = new HashSet<string> { "–±—è—Ö", "–±–µ—à–µ", "–±—è—Ö–º–µ", "–±—è—Ö—Ç–µ", "–±—è—Ö–∞", "–º–æ–∂–µ—à–µ", "–∏—Å–∫–∞—à–µ", "–ø—Ä–∞–≤–µ—à–µ", "—Ö–æ–¥–µ—à–µ", "–ø–∏—à–µ—à–µ", "—á–µ—Ç—è—à–µ" };
            HashSet<string> pastPerfectIndicators = new HashSet<string> { "–±—è—Ö", "–±–µ—à–µ", "–±—è—Ö–º–µ", "–±—è—Ö—Ç–µ", "–±—è—Ö–∞", "–±–∏–ª —Å—ä–º", "–±–∏–ª –µ", "–±–∏–ª–∏ —Å–º–µ", "–±–∏–ª–∏ —Å—Ç–µ", "–±–∏–ª–∏ —Å–∞", "–º–æ–∂–µ–ª —Å—ä–º", "–∏—Å–∫–∞–ª —Å—ä–º", "–ø—Ä–∞–≤–∏–ª —Å—ä–º", "—Ö–æ–¥–∏–ª —Å—ä–º", "–ø–∏—Å–∞–ª —Å—ä–º", "—á–µ–ª —Å—ä–º" };
            HashSet<string> futureTenseIndicators = new HashSet<string> { "—â–µ", "—â–µ –±—ä–¥–∞", "—â–µ –±—ä–¥–µ", "—â–µ –±—ä–¥–µ–º", "—â–µ –±—ä–¥–µ—Ç–µ", "—â–µ –±—ä–¥–∞—Ç", "—â–µ –º–æ–≥–∞", "—â–µ –∏—Å–∫–∞–º", "—â–µ –ø—Ä–∞–≤—è", "—â–µ —Ö–æ–¥—è", "—â–µ –ø–∏—à–∞", "—â–µ —á–µ—Ç–∞" };
            HashSet<string> futureInThePastIndicators = new HashSet<string> { "—â—è—Ö", "—â–µ—à–µ", "—â—è—Ö–º–µ", "—â—è—Ö—Ç–µ", "—â—è—Ö–∞", "—â—è—Ö –¥–∞", "—â–µ—à–µ –¥–∞", "—â—è—Ö–º–µ –¥–∞", "—â—è—Ö—Ç–µ –¥–∞", "—â—è—Ö–∞ –¥–∞" };

            // Split the text into words
            string[] words = text.Split(new[] { ' ', '\t', '\n', '\r', '.', ',', '!', '?', ';', ':', '(', ')' }, StringSplitOptions.RemoveEmptyEntries);

            // Check for tense indicators
            bool hasPresentTense = words.Any(word => presentTenseIndicators.Contains(word.ToLower()));
            bool hasPastIndefiniteTense = words.Any(word => pastIndefiniteIndicators.Contains(word.ToLower()));
            bool hasPastImperfectTense = words.Any(word => pastImperfectIndicators.Contains(word.ToLower()));
            bool hasPastPerfectTense = words.Any(word => pastPerfectIndicators.Contains(word.ToLower()));
            bool hasFutureTense = words.Any(word => futureTenseIndicators.Contains(word.ToLower()));
            bool hasFutureInThePastTense = words.Any(word => futureInThePastIndicators.Contains(word.ToLower()));

            // Determine the tense
            if (hasFutureInThePastTense)
            {
                return "‚ñª–ë—ä–¥–µ—â–µ –≤—Ä–µ–º–µ –≤ –º–∏–Ω–∞–ª–æ—Ç–æ‚óÖ";
            }
            else if (hasFutureTense)
            {
                return "‚ñ∫–ë—ä–¥–µ—â–µ –≤—Ä–µ–º–µ‚óÑ";
            }
            else if (hasPastPerfectTense)
            {
                return "‚ñ∑–ú–∏–Ω–∞–ª–æ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª–Ω–æ –≤—Ä–µ–º–µ‚óÅ";
            }
            else if (hasPastImperfectTense)
            {
                return "‚ó£–ú–∏–Ω–∞–ª–æ –Ω–µ—Å–≤—ä—Ä—à–µ–Ω–æ –≤—Ä–µ–º–µ‚ó¢";
            }
            else if (hasPastIndefiniteTense)
            {
                return "‚ñÄ–ú–∏–Ω–∞–ª–æ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤—Ä–µ–º–µ‚ñÄ";
            }
            else if (hasPresentTense)
            {
                return "‚îè–°–µ–≥–∞—à–Ω–æ –≤—Ä–µ–º–µ‚îì";
            }
            else
            {
                return "‚óå–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ –≤—Ä–µ–º–µ‚óå";
            }
        }
    }
}
